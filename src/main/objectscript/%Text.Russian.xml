<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25" zv="Cache for UNIX (Apple Mac OS X for x86-64) 2014.2 (Build 240U)" ts="2014-05-21 16:05:23">
<Class name="%Text.Russian">
<Description><![CDATA[
See <CLASS>%Text.Text</CLASS>
<p>
The <CLASS>%Text.Russian</CLASS> class implements the Russian language-specific lemmatization algorithm,
initializes the language-specific list of noise words and loads Russian morphological dictionary.
<p class=MsoNormal>© Н.А.Шестакова, 2007 </p>
]]></Description>
<Super>%Text.Text</Super>
<TimeChanged>63328,57902.567772</TimeChanged>
<TimeCreated>60696,37781.22329</TimeCreated>

<Parameter name="DEBUG">
<Description><![CDATA[
<PARAMETER>DEBUG</PARAMETER>  #2: включает запись несловарных лемм в ^CacheTempMorpho("PRE",словоформа)=лемма <BR> ]]></Description>
<Default>0</Default>
</Parameter>

<Parameter name="SOURCELANGUAGE">
<Default>ru</Default>
</Parameter>

<Parameter name="DICTIONARY">
<Default>9</Default>
</Parameter>

<Parameter name="NOISEWORDS100">
<Description>
Список шумовых слов (стоп-слов), наиболее часто встречающихся в языке, которые лишь "раздувают" индексы и практически ничего не дают при полнотекстовом поиске. Список взят с http://forum.searchengines.ru/showthread.php?postid=7670 и http://snowball.tartarus.org/algorithms/russian/stop.txt
и несколько модифицирован (добавлены словоформы). На сайте, рекомендованном в описании %Text.Text (http://www.ranks.nl/stopwords/), русский язык отсутствует.</Description>
<Default>а без будто бы быть в вдруг ведь весь во вот впрочем все всегда всего вы г где год да даже два для до должный ее ей если есть еще ж же за зачем здесь и из или им иногда их к каждый как какой ко когда который кто куда лет ли либо между многий много многое можно мой мочь мы на над надо наконец наш не нельзя несколько нет ни нибудь никак никогда ничто но ну о об один однако он она они оно опять от очень перед по под потом потому про раз разве с сам самый свой</Default>
</Parameter>

<Parameter name="NOISEWORDS200">
<Default>себя сегодня сейчас со совсем та так также таки такой там твой те теперь то тогда тоже только тот три ту тут тута ты у уж хороший хорошо хоть хотя чей через что чтоб чтобы чуть этот я</Default>
</Parameter>

<Parameter name="NGRAMLEN">
<Description><![CDATA[
Список шумовых слов (стоп-слов), наиболее часто встречающихся в языке, которые лишь "раздувают" индексы и практически ничего не дают при полнотекстовом поиске. Список взят с http://forum.searchengines.ru/showthread.php?postid=7670 и http://snowball.tartarus.org/algorithms/russian/stop.txt
и несколько модифицирован (добавлены словоформы). На сайте, рекомендованном в описании %Text.Text (http://www.ranks.nl/stopwords/), русский язык отсутствует.
Параметр сознательно установлен в 1, т.к. это открывает возможность поиска словосочетаний, которая теряется при NGRAMLEN>1. Поясню на примере: <br>
SELECT myDocument, myTitle, myPar FROM ft.doc where myDocument %CONTAINS ('челюстно-лицевого')<br>при NGRAMLEN=2 найдет все тексты, содержащие формы слов "челюстный" и "лицевой" в любых комбинациях,<br>
а при NGRAMLEN=1 - лишь те тексты, которые содержат словосочетания, состоящие из форм слов "челюстный" и "лицевой" (вне зависимости от наличия дефиса, который считается разделителем).<br>
Т.е., будут найдены тексты, содержащие "челюстно лицевой", "челюстно-лицевого" и т.д., но не "челюстной нерв лицевого отдела".<br>
Заметим, что возможность поиска всех комбинаций заданных слов по-прежнему сохраняется:<br>
SELECT myDocument, myTitle, myPar FROM ft.doc where myDocument %CONTAINSTERM ('челюстно','лицевого')<br>
При желании вы, конечно, можете задать NGRAMLEN=2, учтите только, что объем индексов при этом существенно возрастет (в разы).]]></Description>
<Default>1</Default>
</Parameter>

<Method name="stemWord">
<Description><![CDATA[
<METHOD>stemWord</METHOD> - метод лемматизации на основе словаря.
<br>На входе: 
<li>b – словоформа</li>
<br>На выходе:
<li>возвращаемое значение (а также параметр b) – лемма</li>
<li>lb - список ($list) всех возможных вариантов лемм, полученных в результате анализа словоформы b.</li>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&b:%String,&lb:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
#; лемматизируем только кириллицу (возможно с дефисами)!
	if ($l(b)<..#MINWORDLEN) || ($tr(b,"абвгдежзийклмнопрстуфхцчшщъыьэюяё-")'="") set lb=$lb(b) quit b
	set lem=""
	set lb=""
	set k=$l(b) 
	set b=$tr(b, "ё", "е") ;меняем ё на е
	#; Проверяем наличие слова в словаре
	if $data(^Dict(b)) {
    	for {
    		set lem=$order(^Dict(b, lem))
    		quit:(lem="")
    		set lb=lb_$listbuild($get(^Lemma(lem)))
    		}
		}	
	#; Обработка слов с дефисом
	elseif $l(b, "-")>1 {
		s:($data(^Dict($piece(b, "-", 1)_$piece(b, "-", 2, $l(b, "-"))))) b=..stemWord($piece(b, "-", 1)_$piece(b, "-", 2, $l(b, "-")), .lb)
		quit:(lb'="") b
		set lpart=..stemWord($piece(b, "-", 1), .lp)
		set rpart=..stemWord($piece(b, "-", 2, $l(b, "-")), .rp)
		for i=1:1:$ll(lp) {
			for j=1:1:$ll(rp) {
				set lb=lb_$lb($list(lp, i)_"-"_$list(rp, j))
				}			
			}
		}
	#; Если не оказалось в словаре, выполняем процедуру предсказания		
	else {	
		set lb=..Prediction(b) 			
		}

    #;set b=lb ; выдаём список лемм для данной словоформы
	set b=$list(lb, $ll(lb)) ;выдаём последнюю лемму из списка
	quit b
]]></Implementation>
</Method>

<Method name="Prediction">
<Description>
Предсказание незнакомых слов</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&b:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	set lb=..Normalword(b)
	if lb="" {
		set lem=""
		set k=$l(b)
		set sc=0 
		for i=2:1:k { ;отсекаем от слова пошагово по букве с начала
			if (i=k-1)&&(sc=0)&&(..ends(b, k, 2, "ой", .j)) {
				set lb=lb_$lb($e(b, 1, j))
				set sc=1
				}
			if (i=k)&&(sc=0)&&(..ends(b, k, 1, "о", .j)) {
				set lb=lb_$lb(b)
				set sc=1
				}
			quit:(sc=1)
			set stemend=$e(b, i-1, i-1)
			if ..cons(stemend)=1 {
				set cons="cons"
				}
			elseif ..cons(stemend)=0 {
				set cons="vow"
				}	
			set psfl=$e(b, i, k)
			if $data(^Predict(cons, psfl))=10 {
				for {
					set lem=$order(^Predict(cons, psfl, lem))
					quit:(lem="")
					set fl=$get(^Predict(cons, psfl, lem))
					if fl="#" {
						set fl=""
						}
					set lb=lb_$lb($e(b, 1, i-1)_fl)
					}
				set sc=1					
				}
			}
		if (sc=0) { // окончание пустое! // &&(..ends(b, k, 0, "",.j)) {
			set lb=lb_$lb(b)
			}
		}

#if ..#DEBUG#2
	set ^CacheTempMorpho("PRE",b)=lb
#endif

    quit lb
]]></Implementation>
</Method>

<Method name="cons">
<Description>
Процедура проверки, является ли буква согласной</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>k</FormalSpec>
<Private>1</Private>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	quit:("аеёиоуыэюяАЕЁИОУЫЭЮЯ#"[k) 0
	quit 1
]]></Implementation>
</Method>

<Method name="Normalword">
<Description>
Процедура проверки, имеет ли слово продуктивный префикс или продуктивный суффикс</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>b</FormalSpec>
<Private>1</Private>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	set lem=""
	set lb=""
	set k=$l(b)
	set j=""
	if (($e(b, 1, 2)="не")||($e(b, 1, 2)="ре")||($e(b, 1, 2)="за")||($e(b, 1, 2)="до")||($e(b, 1, 2)="де")||($e(b, 1, 2)="по"))&&(k'=2)&&(($data(^Dict($e(b, 3, k))))) {
	    for {
    		set lem=$order(^Dict($e(b, 3, k), lem))
    		quit:(lem="")
    		set lb=lb_$listbuild($e(b, 1, 2)_$get(^Lemma(lem)))
    		}
    	set b=lb	
	    quit b
	}
	if (($e(b, 1, 3)="суб")||($e(b, 1, 3)="нео")||($e(b, 1, 3)="без")||($e(b, 1, 3)="меж")||($e(b, 1, 3)="дез")||($e(b, 1, 3)="пан")||($e(b, 1, 3)="пра")||($e(b, 1, 3)="все")||($e(b, 1, 3)="вне")||($e(b, 1, 3)="дис")||($e(b, 1, 3)="бес")||($e(b, 1, 3)="дву"))&&(k'=3)&&(($data(^Dict($e(b, 4, k))))) {
	    for {
    		set lem=$order(^Dict($e(b, 4, k), lem))
    		quit:(lem="")
    		set lb=lb_$listbuild($e(b, 1, 3)_$get(^Lemma(lem)))
    		}
    	set b=lb	
	    quit b
	}
	if (($e(b, 1, 4)="анти")||($e(b, 1, 4)="обще")||($e(b, 1, 4)="пост")||($e(b, 1, 4)="пред")||($e(b, 1, 4)="полу")||($e(b, 1, 4)="пере")||($e(b, 1, 4)="само")||($e(b, 1, 4)="поли")||($e(b, 1, 4)="одно")||($e(b, 1, 4)="архи")||($e(b, 1, 4)="пара")||($e(b, 1, 4)="недо")||($e(b, 1, 4)="мета")||($e(b, 1, 4)="мало")||($e(b, 1, 4)="мини")||($e(b, 1, 4)="гипо")||($e(b, 1, 4)="двух")||($e(b, 1, 4)="грам")||($e(b, 1, 4)="пери"))&&(k'=4)&&(($data(^Dict($e(b, 5, k))))) {
	    for {
    		set lem=$order(^Dict($e(b, 5, k), lem))
    		quit:(lem="")
    		set lb=lb_$listbuild($e(b, 1, 4)_$get(^Lemma(lem)))
    		}
    	set b=lb
	    quit b
	}
	if (($e(b, 1, 5)="после")||($e(b, 1, 5)="небез")||($e(b, 1, 5)="микро")||($e(b, 1, 5)="контр")||($e(b, 1, 5)="сверх")||($e(b, 1, 5)="квази")||($e(b, 1, 5)="супер")||($e(b, 1, 5)="много")||($e(b, 1, 5)="макро")||($e(b, 1, 5)="гипер")||($e(b, 1, 5)="разно")||($e(b, 1, 5)="около")||($e(b, 1, 5)="низко")||($e(b, 1, 5)="интер"))&&(k'=5)&&(($data(^Dict($e(b, 6, k))))) {
	    for {
    		set lem=$order(^Dict($e(b, 6, k), lem))
    		quit:(lem="")
    		set lb=lb_$listbuild($e(b, 1, 5)_$get(^Lemma(lem)))
    		}
    	set b=lb
	    quit b
	}
	if (($e(b,1,6)="псевдо")||($e(b,1,6)="ультра")||($e(b,1,6)="внутри")||($e(b,1,6)="экстра")||($e(b,1,6)="мульти")||($e(b,1,6)="энтеро"))&&(k'=6)&&(($data(^Dict($e(b, 7, k))))) {
	    for {
    		set lem=$order(^Dict($e(b, 7, k), lem))
    		quit:(lem="")
    		set lb=lb_$listbuild($e(b, 1, 6)_$get(^Lemma(lem)))
    		}
    	set b=lb
	    quit b
	}
	if ($e(b,1,7)="противо")&&(k'=7)&&(($data(^Dict($e(b, 8, k))))) {
		for {
    		set lem=$order(^Dict($e(b, 8, k), lem))
    		quit:(lem="")
    		set lb=lb_$listbuild($e(b, 1, 7)_$get(^Lemma(lem)))
    		}
    	set b=lb
	    quit b
	}
	if ..ends(b, k, 4, "ость", .j)||..ends(b, k, 4, "ости", .j)||..ends(b, k, 5, "остью", .j)||..ends(b, k, 5, "остей", .j)||..ends(b, k, 5, "остям", .j)||..ends(b, k, 6, "остями", .j)||..ends(b, k, 5, "остях", .j) {
		set b=lb_$lb($e(b, 1, j)_"ость")
		quit b
	}
	if ..ends(b, k, 4, "тель", .j)||..ends(b, k, 4, "теля", .j)||..ends(b, k, 4, "телю", .j)||..ends(b, k, 5, "телем", .j)||..ends(b, k, 4, "теле", .j)||..ends(b, k, 4, "тели", .j)||..ends(b, k, 5, "телей", .j)||..ends(b, k, 5, "телям", .j)||..ends(b, k, 6, "телями", .j)||..ends(b, k, 5, "телях", .j) {
		set b=lb_$lb($e(b, 1, j)_"тель")
		quit b
	}
	if ..ends(b, k, 4, "ство", .j)||..ends(b, k, 4, "ства", .j)||..ends(b, k, 4, "ству", .j)||..ends(b, k, 5, "ством", .j)||..ends(b, k, 4, "стве", .j)||..ends(b, k, 4, "ства", .j)||..ends(b, k, 3, "ств", .j)||..ends(b, k, 5, "ствам", .j)||..ends(b, k, 6, "ствами", .j)||..ends(b, k, 5, "ствах", .j) {
		set b=lb_$lb($e(b, 1, j)_"ство")
		quit b
	}
	if ..ends(b, k, 2, "ий", .j)||..ends(b, k, 3, "ого", .j)||..ends(b, k, 3, "ому", .j)||..ends(b, k, 2, "им", .j)||..ends(b, k, 2, "ом", .j)||..ends(b, k, 2, "ое", .j)||..ends(b, k, 2, "ая", .j)||..ends(b, k, 2, "ой", .j)||..ends(b, k, 2, "ую", .j)||..ends(b, k, 2, "ие", .j)||..ends(b, k, 2, "их", .j)||..ends(b, k, 2, "им", .j)||..ends(b, k, 3, "ими", .j) {
		if ($e(b, j)="к") {
		    set b=lb_$lb($e(b, 1, j)_"ий")
		    quit b
		}
	}
	if ..ends(b, k, 2, "ий", .j)||..ends(b, k, 3, "его", .j)||..ends(b, k, 3, "ему", .j)||..ends(b, k, 2, "им", .j)||..ends(b, k, 2, "ем", .j)||..ends(b, k, 2, "ее", .j)||..ends(b, k, 2, "ая", .j)||..ends(b, k, 2, "ей", .j)||..ends(b, k, 2, "ую", .j)||..ends(b, k, 2, "ие", .j)||..ends(b, k, 2, "их", .j)||..ends(b, k, 2, "им", .j)||..ends(b, k, 3, "ими", .j) {
		if ($e(b, j-1, j)="ющ")||($e(b, j-1, j)="ящ")||($e(b, j-1, j)="ущ")||($e(b, j-1, j)="ащ") {
		    set b=lb_$lb($e(b, 1, j)_"ий")
		    quit b
		}
	}
	if ..ends(b, k, 2, "ия", .j)||..ends(b, k, 2, "ии", .j)||..ends(b, k, 2, "ию", .j)||..ends(b, k, 3, "ией", .j)||..ends(b, k, 2, "ий", .j)||..ends(b, k, 3, "иям", .j)||..ends(b, k, 4, "иями", .j)||..ends(b, k, 3, "иях", .j)||..ends(b, k, 2, "ие", .j)||..ends(b, k, 3, "ием", .j) {
		if ($e(b,j-2, j)="фоб")||($e(b, j)="г")||($e(b,j-1, j)="ид")||($e(b, j)="з")||($e(b, j)="к")||($e(b,j-2, j)="фил")||($e(b, j)="м")||($e(b,j-2, j)="ман")||($e(b,j-1, j)="оп")||($e(b,j-5, j)="бактер")||($e(b,j-3, j)="метр")||($e(b,j-1, j)="ур")||($e(b, j)="с")||($e(b, j-2,j)="пат")||($e(b,j-3, j)="дент")||($e(b, j)="ф")||($e(b, j)="х")||($e(b, j)="ц") {
		    set b=lb_$lb($e(b, 1, j)_"ия")
		    quit b
			}
		if ($e(b,j-1, j)="ан")||($e(b, j-1, j)="ен")||($e(b, j-2, j)="ств") {
			set b=lb_$lb($e(b, 1, j)_"ие")
			quit b
			}
		else {
			set b=lb_$lb($e(b, 1, j)_"ия")
			quit b
		}
	}
	if ..ends(b, k, 1, "а", .j)||..ends(b, k, 2, "ом", .j)||..ends(b, k, 1, "е", .j)||..ends(b, k, 1, "ы", .j)||..ends(b, k, 2, "ов", .j)||..ends(b, k, 2, "ам", .j)||..ends(b, k, 3, "ами", .j)||..ends(b, k, 2, "ах", .j)||..ends(b, k, 2, "ой", .j)||..ends(b, k, 2, "ей", .j) {
		if ($e(b, j-1, j)="ид")||($e(b, j-1, j)="аз")||($e(b, j-1, j)="ез")||($e(b, j-1, j)="оз")||($e(b, j-1, j)="ал")||($e(b, j-1, j)="ил")||($e(b, j-1, j)="ол")||($e(b, j-2, j)="изм")||($e(b, j-1, j)="ан")||($e(b, j-1, j)="ен")||($e(b, j-2, j)="ген")||($e(b, j-1, j)="ин")||($e(b, j-4, j)="штейн")||($e(b, j-1, j)="он")||($e(b, j-2, j)="сон")||($e(b, j-3, j)="скоп")||($e(b, j-1, j)="ер")||($e(b, j-2, j)="тор")||($e(b, j-1, j)="ат")||($e(b, j-1, j)="ит")||($e(b, j-2, j)="ист") {
		#;if ($e(b, j-1, j)="ид")||($e(b, j-1, j)="аз")||($e(b, j-1, j)="ёз")||($e(b, j-1, j)="ез")||($e(b, j-1, j)="оз")||($e(b, j-1, j)="ал")||($e(b, j-1, j)="ил")||($e(b, j-1, j)="ол")||($e(b, j-2, j)="изм")||($e(b, j-1, j)="ан")||($e(b, j-1, j)="ен")||($e(b, j-2, j)="ген")||($e(b, j-1, j)="ин")||($e(b, j-4, j)="штейн")||($e(b, j-1, j)="он")||($e(b, j-2, j)="сон")||($e(b, j-3, j)="скоп")||($e(b, j-1, j)="ер")||($e(b, j-1, j)="ёр")||($e(b, j-2, j)="тор")||($e(b, j-1, j)="ат")||($e(b, j-1, j)="ит")||($e(b, j-2, j)="ист") {
			set b=lb_$lb($e(b, 1, j))
			quit b
		}
		if ($e(b,j-1,j)="ом")||($e(b,j-1,j)="ем")||($e(b,j-2,j)="азм")||($e(b, j-4, j)="грамм")||($e(b,j-1,j)="иц") {
		#;if ($e(b,j-1,j)="ом")||($e(b,j-1,j)="ём")||($e(b,j-1,j)="ем")||($e(b,j-2,j)="азм")||($e(b, j-4, j)="грамм")||($e(b,j-1,j)="иц") {			
			set b=lb_$lb($e(b, 1, j)_"а")
			quit b
		}
	}
	if ..ends(b, k, 1, "а", .j)||..ends(b, k, 2, "ом", .j)||..ends(b, k, 1, "е", .j)||..ends(b, k, 2, "ов", .j)||..ends(b, k, 2, "ам", .j)||..ends(b, k, 3, "ами", .j)||..ends(b, k, 2, "ах", .j)||..ends(b, k, 2, "ой", .j)||..ends(b, k, 2, "ей", .j)||..ends(b, k, 1, "и",.j) {
		if ($e(b, j-2, j)="инг")||($e(b, j-3, j)="берг")||($e(b, j-1, j)="ик") {
			set b=lb_$lb($e(b, 1, j))
			quit b
		}
	}
	if ..ends(b, k, 2, "ея", .j)||..ends(b, k, 2, "еи", .j)||..ends(b, k, 2, "ею", .j)||..ends(b, k, 3, "еей", .j)||..ends(b, k, 2, "ей", .j)||..ends(b, k, 3, "еям", .j)||..ends(b, k, 4, "еями", .j)||..ends(b, k, 3, "еях", .j)||..ends(b, k, 2, "ее", .j) {
		if ($e(b, j)="р") {
		    set b=lb_$lb($e(b, 1, j)_"ея")
		    quit b
		}
	}
	if ..ends(b, k, 2, "ый", .j)||..ends(b, k, 3, "ого", .j)||..ends(b, k, 3, "ому", .j)||..ends(b, k, 2, "ым", .j)||..ends(b, k, 2, "ом", .j)||..ends(b, k, 2, "ое", .j)||..ends(b, k, 2, "ая", .j)||..ends(b, k, 2, "ой", .j)||..ends(b, k, 2, "ую", .j)||..ends(b, k, 2, "ые", .j)||..ends(b, k, 2, "ых", .j)||..ends(b, k, 2, "ым", .j)||..ends(b, k, 3, "ыми", .j) {
		if ($e(b, j-1,j)="ов")||($e(b, j)="н")||($e(b, j-2,j)="ист") {
		    set b=lb_$lb($e(b, 1, j)_"ый")
		    quit b
		}
	}
	if ..ends(b, k, 1, "у", .j)||..ends(b, k, 0, "",.j) {
		if ($e(b, j-2, j)="инг")||($e(b, j-3, j)="берг")||($e(b, j-1, j)="ид")||($e(b, j-1, j)="аз")||($e(b, j-1, j)="ез")||($e(b, j-1, j)="оз")||($e(b, j-1, j)="ик")||($e(b, j-1, j)="ал")||($e(b, j-1, j)="ил")||($e(b, j-1, j)="ол")||($e(b, j-2, j)="изм")||($e(b, j-1, j)="ан")||($e(b, j-1, j)="ен")||($e(b, j-2, j)="ген")||($e(b, j-1, j)="ин")||($e(b, j-4, j)="штейн")||($e(b, j-1, j)="он")||($e(b, j-2, j)="сон")||($e(b, j-3, j)="скоп")||($e(b, j-1, j)="ер")||($e(b, j-2, j)="тор")||($e(b, j-1, j)="ат")||($e(b, j-1, j)="ит")||($e(b, j-2, j)="ист") {
		#;if ($e(b, j-2, j)="инг")||($e(b, j-3, j)="берг")||($e(b, j-1, j)="ид")||($e(b, j-1, j)="аз")||($e(b, j-1, j)="ёз")||($e(b, j-1, j)="ез")||($e(b, j-1, j)="оз")||($e(b, j-1, j)="ик")||($e(b, j-1, j)="ал")||($e(b, j-1, j)="ил")||($e(b, j-1, j)="ол")||($e(b, j-2, j)="изм")||($e(b, j-1, j)="ан")||($e(b, j-1, j)="ен")||($e(b, j-2, j)="ген")||($e(b, j-1, j)="ин")||($e(b, j-4, j)="штейн")||($e(b, j-1, j)="он")||($e(b, j-2, j)="сон")||($e(b, j-3, j)="скоп")||($e(b, j-1, j)="ер")||($e(b, j-1, j)="ёр")||($e(b, j-2, j)="тор")||($e(b, j-1, j)="ат")||($e(b, j-1, j)="ит")||($e(b, j-2, j)="ист") {
			set b=lb_$lb($e(b, 1, j))
			quit b
		}
		if ($e(b,j-1,j)="ом")||($e(b,j-1,j)="ем")||($e(b,j-2,j)="азм")||($e(b, j-4, j)="грамм")||($e(b,j-1,j)="иц") {
		#;if ($e(b,j-1,j)="ом")||($e(b,j-1,j)="ём")||($e(b,j-1,j)="ем")||($e(b,j-2,j)="азм")||($e(b, j-4, j)="грамм")||($e(b,j-1,j)="иц") {
			set b=lb_$lb($e(b, 1, j)_"а")
			quit b
		}
	}			
	quit ""
]]></Implementation>
</Method>

<Method name="LoadDict">
<Description><![CDATA[
<METHOD>LoadDict</METHOD> - метод загрузки грамматического словаря из файла
<br>На входе:
<li>filename - полный путь к файлу словаря (http://www.aot.ru/download.php, Морф. словарь (русск.)) </li>
<br>На выходе:
<li>1 - успех, 0 - не удалось открыть файл.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>filename:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 	set sc=..readDictionary(filename, .number)
 	if sc=1 { 
 		do ..inflections(filename)
 		do ..dictionarize(number)
 	}
 	quit sc
]]></Implementation>
</Method>

<Method name="readDictionary">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[filename:%String,&number]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	kill ^CacheTempPdgm1
	kill ^CacheTempA1
	close filename
	open filename:("RK\CP1251\"):5 if '$t { quit 0 }
		use filename
		read stringnum
		for i=1:1:stringnum {
			read str
			set ^CacheTempPdgm1(i)=..formatstr2(str)
			}
		
		do {			
			read str
			} while '(str?6N) 
		if str?6N {
			set number=str	
			for i=1:1:number {
				read str
				set ^CacheTempA1(i)=..formatstr(str)
			}
		}
	close filename
	quit 1
]]></Implementation>
</Method>

<Method name="formatstr">
<ClassMethod>1</ClassMethod>
<FormalSpec>string:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%List</ReturnType>
<Implementation><![CDATA[
 ;делаем из леммы список словоформ
	set string=$ZCONVERT(string ,"L")
	set pdgm=$piece(string, " ",2)+1
	set plist=^CacheTempPdgm1(pdgm)
	set l=$listlength(plist) ;отбрасываем #
	for j=1:1:l {
		set $list(lstring, j)=$piece(string, " ",1) _ $list(plist, j)
		if ($extract($list(lstring, j))="#")&&($extract($list(lstring, j), 2)'="") { 
		set k=$list(lstring, j) 
		set $extract(k)=""
		set $list(lstring, j)=k 
		}
		}
	quit lstring
]]></Implementation>
</Method>

<Method name="formatstr2">
<ClassMethod>1</ClassMethod>
<FormalSpec>string</FormalSpec>
<Private>1</Private>
<ReturnType>%List</ReturnType>
<Implementation><![CDATA[
 ; строку парадигмы приводим к списку окончаний
	set string=$ZCONVERT(string ,"L")
	set lstring=$length(string, "*")
	set paradigm=""
	for j=1:1:lstring {
		if $find($piece(string, "*", j), "%")'=0 {
			set paradigm=paradigm_$listbuild($piece($piece(string, "*", j), "%", 2))
		}
		
		}
	quit paradigm
]]></Implementation>
</Method>

<Method name="dictionarize">
<ClassMethod>1</ClassMethod>
<FormalSpec>number</FormalSpec>
<Private>1</Private>
<Implementation><![CDATA[
 ;все слова в своём глобале, словоформы в своём, 
 ;С УЧЁТОМ ГРАММАТИЧЕСКОЙ НЕОДНОЗНАЧНОСТИ.
	kill ^Lemma
	kill ^Dict
	for i=1:1:number {
		set wlist=^CacheTempA1(i)
		set ^Lemma(i)=$list(wlist, 1)
		set b=$listlength(wlist)
		for j=1:1:b {
			set ^Dict($tr($list(wlist, j), "ё","е"),i)=""
			}
	}
	kill ^CacheTempPdgm1
	kill ^CacheTempA1
]]></Implementation>
</Method>

<Method name="inflections">
<ClassMethod>1</ClassMethod>
<FormalSpec>filename:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 
	kill ^Predict ;глобал для предсказания
	close filename
	open filename:("RK\CP1251\")
		use filename
		do {			
			read str
			} while '(str?6N) 
		if str?6N {
			set number=str	
			for i=1:1:number {
				read str
				set stem=$piece(str, " ", 1)
				set l=$l(stem)
				set k=$piece(str, " ", 2)
				if ..cons($e(stem, l))=1 {		
					if $data(a(k))=0 {
						set a(k)=1
						set array(i)=k
						set letter(k)="cons"
						}
					else {
						set b=$get(a(k))
						set a(k)=b+1
						if letter(k)="vow" {
							set letter(k)="letter"
							}
						}
					}
				elseif ..cons($e(stem, l))=0 {		
					if $data(a(k))=0 {
						set a(k)=1
						set array(i)=k
						set letter(k)="vow"
						}
					else {
						set b=$get(a(k))
						set a(k)=b+1
						if letter(k)="cons" {
							set letter(k)="letter"
							}
						}
					}
				}
			}
	close filename
	for i=1:1:number {
		set m=$get(array(i))
		if $data(array(i))'=0, a(m)>247, letter(m)="cons"||"letter" {
			set plist=$get(^CacheTempPdgm1(m+1))
			set b=$listlength(plist)
			for j=1:1:b {
				if $list(plist, j)="" {
					set $list(plist, j)="#"
					}
				}			
			for j=1:1:b {
				set d=$list(plist, 1)
				set u=$list(plist, j)
				set t=""			
				for {
					set sc=0
					set t=$order(^Predict("cons", u, t))
					quit:(t="")
					if $get(^Predict("cons", u,t))=d, t<(a(m)) {
						set ^Predict("cons", u, a(m))=d
						kill ^Predict("cons", u,t)
						set sc=1
						quit
						}
					elseif $get(^Predict("cons", u,t))=d, t>=(a(m)) {
						set sc=1
						quit
						}
					}
				if sc=0 {
					set ^Predict("cons", u, a(m))=d
					}
				}
			}
		if $data(array(i))'=0, a(m)>247, letter(m)="vow"||"letter" {
			set plist=$get(^CacheTempPdgm1(m+1))
			set b=$listlength(plist)
			for j=1:1:b {
				if $list(plist, j)="" {
					set $list(plist, j)="#"
					}
				}			
			for j=1:1:b {
				set d=$list(plist, 1)
				set u=$list(plist, j)
				set t=""			
				for {
					set sc=0
					set t=$order(^Predict("vow", u, t))
					quit:(t="")
					if $get(^Predict("vow", u,t))=d, t<(a(m)) {
						set ^Predict("vow", u, a(m))=d
						kill ^Predict("vow", u,t)
						set sc=1
						quit
						}
					elseif $get(^Predict("vow", u,t))=d, t>=(a(m)) {
						set sc=1
						quit
						}
					}
				if sc=0 {
					set ^Predict("vow", u, a(m))=d
					}
				}
			}
 		}
]]></Implementation>
</Method>
</Class>
</Export>
